<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>zstd 1.3.0 Manual</title>
</head>
<body>
<h1>zstd 1.3.0 Manual</h1>
<hr>
<a name="Contents"></a><h2>Contents</h2>
<ol>
<li><a href="#Chapter1">Introduction</a></li>
<li><a href="#Chapter2">Version</a></li>
<li><a href="#Chapter3">Simple API</a></li>
<li><a href="#Chapter4">Explicit memory management</a></li>
<li><a href="#Chapter5">Simple dictionary API</a></li>
<li><a href="#Chapter6">Fast dictionary API</a></li>
<li><a href="#Chapter7">Streaming</a></li>
<li><a href="#Chapter8">Streaming compression - HowTo</a></li>
<li><a href="#Chapter9">Streaming decompression - HowTo</a></li>
<li><a href="#Chapter10">START OF ADVANCED AND EXPERIMENTAL FUNCTIONS</a></li>
<li><a href="#Chapter11">Advanced types</a></li>
<li><a href="#Chapter12">Frame size functions</a></li>
<li><a href="#Chapter13">Context memory usage</a></li>
<li><a href="#Chapter14">Advanced compression functions</a></li>
<li><a href="#Chapter15">Advanced decompression functions</a></li>
<li><a href="#Chapter16">Advanced streaming functions</a></li>
<li><a href="#Chapter17">Buffer-less and synchronous inner streaming functions</a></li>
<li><a href="#Chapter18">Buffer-less streaming compression (synchronous mode)</a></li>
<li><a href="#Chapter19">Buffer-less streaming decompression (synchronous mode)</a></li>
<li><a href="#Chapter20">Block functions</a></li>
</ol>
<hr>
<a name="Chapter1"></a><h2>Introduction</h2><pre>
  zstd, short for Zstandard, is a fast lossless compression algorithm,
  targeting real-time compression scenarios at zlib-level and better compression ratios.
  The zstd compression library provides in-memory compression and decompression functions.
  The library supports compression levels from 1 up to ZSTD_maxCLevel() which is currently 22.
  Levels >= 20, labeled `--ultra`, should be used with caution, as they require more memory.
  Compression can be done in:
    - a single step (described as Simple API)
    - a single step, reusing a context (described as Explicit memory management)
    - unbounded multiple steps (described as Streaming compression)
  The compression ratio achievable on small data can be highly improved using compression with a dictionary in:
    - a single step (described as Simple dictionary API)
    - a single step, reusing a dictionary (described as Fast dictionary API)

  Advanced experimental functions can be accessed using #define ZSTD_STATIC_LINKING_ONLY before including zstd.h.
  These APIs shall never be used with a dynamic library.
  They are not "stable", their definition may change in the future. Only static linking is allowed.
<BR></pre>

<a name="Chapter2"></a><h2>Version</h2><pre></pre>

<pre><b>unsigned ZSTD_versionNumber(void);   </b>/**< to be used when checking dll version */<b>
</b></pre><BR>
<a name="Chapter3"></a><h2>Simple API</h2><pre></pre>

<pre><b>size_t ZSTD_compress( void* dst, size_t dstCapacity,
                const void* src, size_t srcSize,
                      int compressionLevel);
</b><p>  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`.
  @return : compressed size written into `dst` (<= `dstCapacity),
            or an error code if it fails (which can be tested using ZSTD_isError()). 
</p></pre><BR>

<pre><b>size_t ZSTD_decompress( void* dst, size_t dstCapacity,
                  const void* src, size_t compressedSize);
</b><p>  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
  `dstCapacity` is an upper bound of originalSize.
  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
            or an errorCode if it fails (which can be tested using ZSTD_isError()). 
</p></pre><BR>

<pre><b>unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize);
</b><p>  NOTE: This function is planned to be obsolete, in favor of ZSTD_getFrameContentSize().
  ZSTD_getFrameContentSize() works the same way,
  returning the decompressed size of a single frame,
  but distinguishes empty frames from frames with an unknown size, or errors.

  'src' is the start of a zstd compressed frame.
  @return : content size to be decompressed, as a 64-bits value _if known_, 0 otherwise.
   note 1 : decompressed size is an optional field, it may not be present, typically in streaming mode.
            When `return==0`, data to decompress could be any size.
            In which case, it's necessary to use streaming mode to decompress data.
            Optionally, application can use ZSTD_decompress() while relying on implied limits.
            (For example, data may be necessarily cut into blocks <= 16 KB).
   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
   note 3 : decompressed size can be very large (64-bits value),
            potentially larger than what local system can handle as a single memory segment.
            In which case, it's necessary to use streaming mode to decompress data.
   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
            Always ensure result fits within application's authorized limits.
            Each application can set its own limits.
   note 5 : when `return==0`, if precise failure cause is needed, use ZSTD_getFrameParams() to know more. 
</p></pre><BR>

<h3>Helper functions</h3><pre></pre><b><pre>int         ZSTD_maxCLevel(void);               </b>/*!< maximum compression level available */<b>
size_t      ZSTD_compressBound(size_t srcSize); </b>/*!< maximum compressed size in worst case scenario */<b>
unsigned    ZSTD_isError(size_t code);          </b>/*!< tells if a `size_t` function result is an error code */<b>
const char* ZSTD_getErrorName(size_t code);     </b>/*!< provides readable string from an error code */<b>
</pre></b><BR>
<a name="Chapter4"></a><h2>Explicit memory management</h2><pre></pre>

<h3>Compression context</h3><pre>  When compressing many times,
  it is recommended to allocate a context just once, and re-use it for each successive compression operation.
  This will make workload friendlier for system's memory.
  Use one context per thread for parallel execution in multi-threaded environments. 
</pre><b><pre>typedef struct ZSTD_CCtx_s ZSTD_CCtx;
ZSTD_CCtx* ZSTD_createCCtx(void);
size_t     ZSTD_freeCCtx(ZSTD_CCtx* cctx);
</pre></b><BR>
<pre><b>size_t ZSTD_compressCCtx(ZSTD_CCtx* ctx,
                         void* dst, size_t dstCapacity,
                   const void* src, size_t srcSize,
                         int compressionLevel);
</b><p>  Same as ZSTD_compress(), requires an allocated ZSTD_CCtx (see ZSTD_createCCtx()). 
</p></pre><BR>

<h3>Decompression context</h3><pre>  When decompressing many times,
  it is recommended to allocate a context only once,
  and re-use it for each successive compression operation.
  This will make workload friendlier for system's memory.
  Use one context per thread for parallel execution. 
</pre><b><pre>typedef struct ZSTD_DCtx_s ZSTD_DCtx;
ZSTD_DCtx* ZSTD_createDCtx(void);
size_t     ZSTD_freeDCtx(ZSTD_DCtx* dctx);
</pre></b><BR>
<pre><b>size_t ZSTD_decompressDCtx(ZSTD_DCtx* ctx,
                           void* dst, size_t dstCapacity,
                     const void* src, size_t srcSize);
</b><p>  Same as ZSTD_decompress(), requires an allocated ZSTD_DCtx (see ZSTD_createDCtx()) 
</p></pre><BR>

<a name="Chapter5"></a><h2>Simple dictionary API</h2><pre></pre>

<pre><b>size_t ZSTD_compress_usingDict(ZSTD_CCtx* ctx,
                               void* dst, size_t dstCapacity,
                         const void* src, size_t srcSize,
                         const void* dict,size_t dictSize,
                               int compressionLevel);
</b><p>   Compression using a predefined Dictionary (see dictBuilder/zdict.h).
   Note : This function loads the dictionary, resulting in significant startup delay.
   Note : When `dict == NULL || dictSize < 8` no dictionary is used. 
</p></pre><BR>

<pre><b>size_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,
                                 void* dst, size_t dstCapacity,
                           const void* src, size_t srcSize,
                           const void* dict,size_t dictSize);
</b><p>   Decompression using a predefined Dictionary (see dictBuilder/zdict.h).
   Dictionary must be identical to the one used during compression.
   Note : This function loads the dictionary, resulting in significant startup delay.
   Note : When `dict == NULL || dictSize < 8` no dictionary is used. 
</p></pre><BR>

<a name="Chapter6"></a><h2>Fast dictionary API</h2><pre></pre>

<pre><b>ZSTD_CDict* ZSTD_createCDict(const void* dictBuffer, size_t dictSize,
                             int compressionLevel);
</b><p>   When compressing multiple messages / blocks with the same dictionary, it's recommended to load it just once.
   ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.
   ZSTD_CDict can be created once and used by multiple threads concurrently, as its usage is read-only.
   `dictBuffer` can be released after ZSTD_CDict creation, as its content is copied within CDict 
</p></pre><BR>

<pre><b>size_t      ZSTD_freeCDict(ZSTD_CDict* CDict);
</b><p>   Function frees memory allocated by ZSTD_createCDict(). 
</p></pre><BR>

<pre><b>size_t ZSTD_compress_usingCDict(ZSTD_CCtx* cctx,
                                void* dst, size_t dstCapacity,
                          const void* src, size_t srcSize,
                          const ZSTD_CDict* cdict);
</b><p>  Compression using a digested Dictionary.
  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times.
  Note that compression level is decided during dictionary creation.
  Frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) 
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict(const void* dictBuffer, size_t dictSize);
</b><p>   Create a digested dictionary, ready to start decompression operation without startup delay.
   dictBuffer can be released after DDict creation, as its content is copied inside DDict 
</p></pre><BR>

<pre><b>size_t      ZSTD_freeDDict(ZSTD_DDict* ddict);
</b><p>   Function frees memory allocated with ZSTD_createDDict() 
</p></pre><BR>

<pre><b>size_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,
                                  void* dst, size_t dstCapacity,
                            const void* src, size_t srcSize,
                            const ZSTD_DDict* ddict);
</b><p>   Decompression using a digested Dictionary.
   Faster startup than ZSTD_decompress_usingDict(), recommended when same dictionary is used multiple times. 
</p></pre><BR>

<a name="Chapter7"></a><h2>Streaming</h2><pre></pre>

<pre><b>typedef struct ZSTD_inBuffer_s {
  const void* src;    </b>/**< start of input buffer */<b>
  size_t size;        </b>/**< size of input buffer */<b>
  size_t pos;         </b>/**< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size */<b>
} ZSTD_inBuffer;
</b></pre><BR>
<pre><b>typedef struct ZSTD_outBuffer_s {
  void*  dst;         </b>/**< start of output buffer */<b>
  size_t size;        </b>/**< size of output buffer */<b>
  size_t pos;         </b>/**< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size */<b>
} ZSTD_outBuffer;
</b></pre><BR>
<a name="Chapter8"></a><h2>Streaming compression - HowTo</h2><pre>
  A ZSTD_CStream object is required to track streaming operation.
  Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources.
  ZSTD_CStream objects can be reused multiple times on consecutive compression operations.
  It is recommended to re-use ZSTD_CStream in situations where many streaming operations will be achieved consecutively,
  since it will play nicer with system's memory, by re-using already allocated memory.
  Use one separate ZSTD_CStream per thread for parallel execution.

  Start a new compression by initializing ZSTD_CStream.
  Use ZSTD_initCStream() to start a new compression operation.
  Use ZSTD_initCStream_usingDict() or ZSTD_initCStream_usingCDict() for a compression which requires a dictionary (experimental section)

  Use ZSTD_compressStream() repetitively to consume input stream.
  The function will automatically update both `pos` fields.
  Note that it may not consume the entire input, in which case `pos < size`,
  and it's up to the caller to present again remaining data.
  @return : a size hint, preferred nb of bytes to use as input for next function call
            or an error code, which can be tested using ZSTD_isError().
            Note 1 : it's just a hint, to help latency a little, any other value will work fine.
            Note 2 : size hint is guaranteed to be <= ZSTD_CStreamInSize()

  At any moment, it's possible to flush whatever data remains within internal buffer, using ZSTD_flushStream().
  `output->pos` will be updated.
  Note that some content might still be left within internal buffer if `output->size` is too small.
  @return : nb of bytes still present within internal buffer (0 if it's empty)
            or an error code, which can be tested using ZSTD_isError().

  ZSTD_endStream() instructs to finish a frame.
  It will perform a flush and write frame epilogue.
  The epilogue is required for decoders to consider a frame completed.
  ZSTD_endStream() may not be able to flush full data if `output->size` is too small.
  In which case, call again ZSTD_endStream() to complete the flush.
  @return : 0 if frame fully completed and fully flushed,
             or >0 if some data is still present within internal buffer
                  (value is minimum size estimation for remaining data to flush, but it could be more)
            or an error code, which can be tested using ZSTD_isError().

 
<BR></pre>

<pre><b>typedef ZSTD_CCtx ZSTD_CStream;  </b>/**< CCtx and CStream are effectively same object */<b>
</b></pre><BR>
<h3>ZSTD_CStream management functions</h3><pre></pre><b><pre>ZSTD_CStream* ZSTD_createCStream(void);
size_t ZSTD_freeCStream(ZSTD_CStream* zcs);
</pre></b><BR>
<h3>Streaming compression functions</h3><pre></pre><b><pre>size_t ZSTD_initCStream(ZSTD_CStream* zcs, int compressionLevel);
size_t ZSTD_compressStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
size_t ZSTD_flushStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
size_t ZSTD_endStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
</pre></b><BR>
<pre><b>size_t ZSTD_CStreamInSize(void);    </b>/**< recommended size for input buffer */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_CStreamOutSize(void);   </b>/**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block in all circumstances. */<b>
</b></pre><BR>
<a name="Chapter9"></a><h2>Streaming decompression - HowTo</h2><pre>
  A ZSTD_DStream object is required to track streaming operations.
  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources.
  ZSTD_DStream objects can be re-used multiple times.

  Use ZSTD_initDStream() to start a new decompression operation,
   or ZSTD_initDStream_usingDict() if decompression requires a dictionary.
   @return : recommended first input size

  Use ZSTD_decompressStream() repetitively to consume your input.
  The function will update both `pos` fields.
  If `input.pos < input.size`, some input has not been consumed.
  It's up to the caller to present again remaining data.
  If `output.pos < output.size`, decoder has flushed everything it could.
  @return : 0 when a frame is completely decoded and fully flushed,
            an error code, which can be tested using ZSTD_isError(),
            any other value > 0, which means there is still some decoding to do to complete current frame.
            The return value is a suggested next input size (a hint to improve latency) that will never load more than the current frame.
 
<BR></pre>

<h3>ZSTD_DStream management functions</h3><pre></pre><b><pre>ZSTD_DStream* ZSTD_createDStream(void);
size_t ZSTD_freeDStream(ZSTD_DStream* zds);
</pre></b><BR>
<h3>Streaming decompression functions</h3><pre></pre><b><pre>size_t ZSTD_initDStream(ZSTD_DStream* zds);
size_t ZSTD_decompressStream(ZSTD_DStream* zds, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
</pre></b><BR>
<pre><b>size_t ZSTD_DStreamInSize(void);    </b>/*!< recommended size for input buffer */<b>
</b></pre><BR>
<pre><b>size_t ZSTD_DStreamOutSize(void);   </b>/*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */<b>
</b></pre><BR>
<a name="Chapter10"></a><h2>START OF ADVANCED AND EXPERIMENTAL FUNCTIONS</h2><pre> The definitions in this section are considered experimental.
 They should never be used with a dynamic library, as they may change in the future.
 They are provided for advanced usages.
 Use them only in association with static linking.
 
<BR></pre>

<a name="Chapter11"></a><h2>Advanced types</h2><pre></pre>

<pre><b>typedef enum { ZSTD_fast=1, ZSTD_dfast, ZSTD_greedy, ZSTD_lazy, ZSTD_lazy2,
               ZSTD_btlazy2, ZSTD_btopt, ZSTD_btultra } ZSTD_strategy;   </b>/* from faster to stronger */<b>
</b></pre><BR>
<pre><b>typedef struct {
    unsigned windowLog;      </b>/**< largest match distance : larger == more compression, more memory needed during decompression */<b>
    unsigned chainLog;       </b>/**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */<b>
    unsigned hashLog;        </b>/**< dispatch table : larger == faster, more memory */<b>
    unsigned searchLog;      </b>/**< nb of searches : larger == more compression, slower */<b>
    unsigned searchLength;   </b>/**< match length searched : larger == faster decompression, sometimes less compression */<b>
    unsigned targetLength;   </b>/**< acceptable match size for optimal parser (only) : larger == more compression, slower */<b>
    ZSTD_strategy strategy;
} ZSTD_compressionParameters;
</b></pre><BR>
<pre><b>typedef struct {
    unsigned contentSizeFlag; </b>/**< 1: content size will be in frame header (when known) */<b>
    unsigned checksumFlag;    </b>/**< 1: generate a 32-bits checksum at end of frame, for error detection */<b>
    unsigned noDictIDFlag;    </b>/**< 1: no dictID will be saved into frame header (if dictionary compression) */<b>
} ZSTD_frameParameters;
</b></pre><BR>
<pre><b>typedef struct {
    ZSTD_compressionParameters cParams;
    ZSTD_frameParameters fParams;
} ZSTD_parameters;
</b></pre><BR>
<pre><b>typedef struct {
    unsigned long long frameContentSize;
    unsigned windowSize;
    unsigned dictID;
    unsigned checksumFlag;
} ZSTD_frameHeader;
</b></pre><BR>
<h3>Custom memory allocation functions</h3><pre></pre><b><pre>typedef void* (*ZSTD_allocFunction) (void* opaque, size_t size);
typedef void  (*ZSTD_freeFunction) (void* opaque, void* address);
typedef struct { ZSTD_allocFunction customAlloc; ZSTD_freeFunction customFree; void* opaque; } ZSTD_customMem;
</pre></b><BR>
<a name="Chapter12"></a><h2>Frame size functions</h2><pre></pre>

<pre><b>size_t ZSTD_findFrameCompressedSize(const void* src, size_t srcSize);
</b><p>  `src` should point to the start of a ZSTD encoded frame or skippable frame
  `srcSize` must be at least as large as the frame
  @return : the compressed size of the frame pointed to by `src`,
            suitable to pass to `ZSTD_decompress` or similar,
            or an error code if given invalid input. 
</p></pre><BR>

<pre><b>#define ZSTD_CONTENTSIZE_UNKNOWN (0ULL - 1)
#define ZSTD_CONTENTSIZE_ERROR   (0ULL - 2)
unsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize);
</b><p>  `src` should point to the start of a ZSTD encoded frame.
  `srcSize` must be at least as large as the frame header.
       A value >= `ZSTD_frameHeaderSize_max` is guaranteed to be large enough.
  @return : - decompressed size of the frame pointed to be `src` if known
            - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
            - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) 
</p></pre><BR>

<pre><b>unsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize);
</b><p>  `src` should point the start of a series of ZSTD encoded and/or skippable frames
  `srcSize` must be the _exact_ size of this series
       (i.e. there should be a frame boundary exactly `srcSize` bytes after `src`)
  @return : - decompressed size of all data in all successive frames
            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
            - if an error occurred: ZSTD_CONTENTSIZE_ERROR

   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
            In which case, it's necessary to use streaming mode to decompress data.
            Optionally, application can still use ZSTD_decompress() while relying on implied limits.
            (For example, data may be necessarily cut into blocks <= 16 KB).
   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
   note 3 : decompressed size can be very large (64-bits value),
            potentially larger than what local system can handle as a single memory segment.
            In which case, it's necessary to use streaming mode to decompress data.
   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
            Always ensure result fits within application's authorized limits.
            Each application can set its own limits.
   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to
            read each contained frame header.  This is efficient as most of the data is skipped,
            however it does mean that all frame data must be present and valid. 
</p></pre><BR>

<a name="Chapter13"></a><h2>Context memory usage</h2><pre></pre>

<pre><b>size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx);
size_t ZSTD_sizeof_DCtx(const ZSTD_DCtx* dctx);
size_t ZSTD_sizeof_CStream(const ZSTD_CStream* zcs);
size_t ZSTD_sizeof_DStream(const ZSTD_DStream* zds);
size_t ZSTD_sizeof_CDict(const ZSTD_CDict* cdict);
size_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict);
</b><p>  These functions give the current memory usage of selected object.
  Object memory usage can evolve if it's re-used multiple times. 
</p></pre><BR>

<pre><b>size_t ZSTD_estimateCCtxSize(ZSTD_compressionParameters cParams);
size_t ZSTD_estimateDCtxSize(void);
</b><p>  These functions make it possible to estimate memory usage
  of a future target object, before its allocation,
  given a set of parameters, which vary depending on target object.
  The objective is to guide decision before allocation. 
</p></pre><BR>

<pre><b>size_t ZSTD_estimateCStreamSize(ZSTD_compressionParameters cParams);
size_t ZSTD_estimateDStreamSize(ZSTD_frameHeader fHeader);
</b><p>  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),
         an internal ?Dict will be created, which size is not estimated.
         In this case, get additional size by using ZSTD_estimate?DictSize 
</p></pre><BR>

<pre><b>size_t ZSTD_estimateCDictSize(ZSTD_compressionParameters cParams, size_t dictSize, unsigned byReference);
size_t ZSTD_estimateDDictSize(size_t dictSize, unsigned byReference);
</b><p>  Note : dictionary created "byReference" are smaller 
</p></pre><BR>

<a name="Chapter14"></a><h2>Advanced compression functions</h2><pre></pre>

<pre><b>ZSTD_CCtx* ZSTD_createCCtx_advanced(ZSTD_customMem customMem);
</b><p>  Create a ZSTD compression context using external alloc and free functions 
</p></pre><BR>

<pre><b>ZSTD_CCtx* ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize);
</b><p>  workspace: The memory area to emplace the context into.
             Provided pointer must 8-bytes aligned.
             It must outlive context usage.
  workspaceSize: Use ZSTD_estimateCCtxSize() or ZSTD_estimateCStreamSize()
                 to determine how large workspace must be to support scenario.
 @return : pointer to ZSTD_CCtx*, or NULL if error (size too small)
  Note : zstd will never resize nor malloc() when using a static cctx.
         If it needs more memory than available, it will simply error out.
  Note 2 : there is no corresponding "free" function.
           Since workspace was allocated externally, it must be freed externally too.
  Limitation : currently not compatible with internal CDict creation, such as
               ZSTD_CCtx_loadDictionary() or ZSTD_initCStream_usingDict().
 
</p></pre><BR>

<pre><b>typedef enum {
    ZSTD_p_forceWindow,   </b>/* Force back-references to remain < windowSize, even when referencing Dictionary content (default:0) */<b>
    ZSTD_p_forceRawDict   </b>/* Force loading dictionary in "content-only" mode (no header analysis) */<b>
} ZSTD_CCtxParameter;
</b></pre><BR>
<pre><b>size_t ZSTD_setCCtxParameter(ZSTD_CCtx* cctx, ZSTD_CCtxParameter param, unsigned value);
</b><p>  Set advanced parameters, selected through enum ZSTD_CCtxParameter
  @result : 0, or an error code (which can be tested with ZSTD_isError()) 
</p></pre><BR>

<pre><b>ZSTD_CDict* ZSTD_createCDict_byReference(const void* dictBuffer, size_t dictSize, int compressionLevel);
</b><p>  Create a digested dictionary for compression
  Dictionary content is simply referenced, and therefore stays in dictBuffer.
  It is important that dictBuffer outlives CDict, it must remain read accessible throughout the lifetime of CDict 
</p></pre><BR>

<pre><b>ZSTD_CDict* ZSTD_createCDict_advanced(const void* dict, size_t dictSize, unsigned byReference,
                                      ZSTD_compressionParameters cParams, ZSTD_customMem customMem);
</b><p>  Create a ZSTD_CDict using external alloc and free, and customized compression parameters 
</p></pre><BR>

<pre><b>ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
</b><p>   @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
   `estimatedSrcSize` value is optional, select 0 if not known 
</p></pre><BR>

<pre><b>ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
</b><p>   same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.
   All fields of `ZSTD_frameParameters` are set to default (0) 
</p></pre><BR>

<pre><b>size_t ZSTD_checkCParams(ZSTD_compressionParameters params);
</b><p>   Ensure param values remain within authorized range 
</p></pre><BR>

<pre><b>ZSTD_compressionParameters ZSTD_adjustCParams(ZSTD_compressionParameters cPar, unsigned long long srcSize, size_t dictSize);
</b><p>   optimize params for a given `srcSize` and `dictSize`.
   both values are optional, select `0` if unknown. 
</p></pre><BR>

<pre><b>size_t ZSTD_compress_advanced (ZSTD_CCtx* cctx,
                      void* dst, size_t dstCapacity,
                const void* src, size_t srcSize,
                const void* dict,size_t dictSize,
                      ZSTD_parameters params);
</b><p>   Same as ZSTD_compress_usingDict(), with fine-tune control over each compression parameter 
</p></pre><BR>

<pre><b>size_t ZSTD_compress_usingCDict_advanced(ZSTD_CCtx* cctx,
                      void* dst, size_t dstCapacity,
                const void* src, size_t srcSize,
                const ZSTD_CDict* cdict, ZSTD_frameParameters fParams);
</b><p>   Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters 
</p></pre><BR>

<h3>New experimental advanced parameters API</h3><pre></pre><b><pre></pre></b><BR>
<pre><b>typedef enum {
    </b>/* compression parameters */<b>
    ZSTD_p_compressionLevel=100, </b>/* Update all compression parameters according to pre-defined cLevel table<b>
                              * Default level is 3.
                              * Special: value 0 means "do not change cLevel". */
    ZSTD_p_windowLog,        </b>/* Maximum allowed back-reference distance, expressed as power of 2.<b>
                              * Must be clamped between ZSTD_WINDOWLOG_MIN and ZSTD_WINDOWLOG_MAX.
                              * default value : set through compressionLevel.
                              * Special: value 0 means "do not change windowLog". */
    ZSTD_p_hashLog,          </b>/* Size of the probe table, as a power of 2.<b>
                              * Resulting table size is (1 << (hashLog+2)).
                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX.
                              * Larger tables improve compression ratio of strategies <= dFast,
                              * and improve speed of strategies > dFast.
                              * Special: value 0 means "do not change hashLog". */
    ZSTD_p_chainLog,         </b>/* Size of the full-search table, as a power of 2.<b>
                              * Resulting table size is (1 << (chainLog+2)).
                              * Larger tables result in better and slower compression.
                              * This parameter is useless when using "fast" strategy.
                              * Special: value 0 means "do not change chainLog". */
    ZSTD_p_searchLog,        </b>/* Number of search attempts, as a power of 2.<b>
                              * More attempts result in better and slower compression.
                              * This parameter is useless when using "fast" and "dFast" strategies.
                              * Special: value 0 means "do not change searchLog". */
    ZSTD_p_minMatch,         </b>/* Minimum size of searched matches (note : repCode matches can be smaller).<b>
                              * Larger values make faster compression and decompression, but decrease ratio.
                              * Must be clamped between ZSTD_SEARCHLENGTH_MIN and ZSTD_SEARCHLENGTH_MAX.
                              * Note that currently, for all strategies < btopt, effective minimum is 4.
                              * Note that currently, for all strategies > fast, effective maximum is 6.
                              * Special: value 0 means "do not change minMatchLength". */
    ZSTD_p_targetLength,     </b>/* Only useful for strategies >= btopt.<b>
                              * Length of Match considered "good enough" to stop search.
                              * Larger values make compression stronger and slower.
                              * Special: value 0 means "do not change targetLength". */
    ZSTD_p_compressionStrategy, </b>/* See ZSTD_strategy enum definition.<b>
                              * Cast selected strategy as unsigned for ZSTD_CCtx_setParameter() compatibility.
                              * The higher the value of selected strategy, the more complex it is,
                              * resulting in stronger and slower compression.
                              * Special: value 0 means "do not change strategy". */
#if 0
    ZSTD_p_windowSize,       </b>/* Maximum allowed back-reference distance.<b>
                              * Can be set to a more precise value than windowLog.
                              * Will be transparently reduced to closest possible inferior value
                              * (see Zstandard compression format) */
                             </b>/* Not ready yet ! */<b>
#endif

    </b>/* frame parameters */<b>
    ZSTD_p_contentSizeFlag=200, </b>/* Content size is written into frame header _whenever known_ (default:1) */<b>
    ZSTD_p_checksumFlag,     </b>/* A 32-bits checksum of content is written at end of frame (default:0) */<b>
    ZSTD_p_dictIDFlag,       </b>/* When applicable, dictID of dictionary is provided in frame header (default:1) */<b>

    </b>/* dictionary parameters */<b>
    ZSTD_p_refDictContent=300, </b>/* Content of dictionary content will be referenced, instead of copied (default:0).<b>
                              * This avoids duplicating dictionary content.
                              * But it also requires that dictionary buffer outlives its user (CDict) */
                             </b>/* Not ready yet ! */<b>
    ZSTD_p_rawContentDict,   </b>/* load dictionary in "content-only" mode (no header analysis) (default:0) */<b>
                             </b>/* question : should there be an option to load dictionary only in zstd format, rejecting others with an error code ? */<b>

#if 0
    </b>/* multi-threading parameters (not ready yet !) */<b>
    ZSTD_p_nbThreads=400,    </b>/* Select how many threads a compression job can spawn (default:1)<b>
                              * More threads improve speed, but increases also memory usage */
    ZSTDMT_p_jobSize,        </b>/* Size of a compression job. Each job is compressed in parallel.<b>
                              * 0 means default, which is dynamically determined based on compression parameters.
                              * Job size must be a minimum of overlapSize, or 1 KB, whichever is largest
                              * The minimum size is automatically and transparently enforced */
    ZSTDMT_p_overlapSizeLog, </b>/* Size of previous input reloaded at the beginning of each job.<b>
                              * 0 => no overlap, 6(default) => use 1/8th of windowSize, >=9 => use full windowSize */
#endif

    </b>/* advanced parameters - may not remain available after API update */<b>
    ZSTD_p_forceMaxWindow=1100, </b>/* Force back-references to remain < windowSize,<b>
                              * even when referencing into Dictionary content
                              * default : 0 when using a CDict, 1 when using a Prefix */
} ZSTD_cParameter;
</b></pre><BR>
<pre><b>size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, unsigned value);
</b><p>  Set one compression parameter, selected by enum ZSTD_cParameter.
  Note : when `value` is an enum, cast it to unsigned for proper type checking.
  @result : 0, or an error code (which can be tested with ZSTD_isError()). 
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize);
</b><p>  Total input data size to be compressed into a single frame.
  This value will be controlled at the end, and result in error if not respected.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Note 1 : 0 means zero, empty.
           In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.
           Note that ZSTD_CONTENTSIZE_UNKNOWN is default value for all new compression jobs.
  Note 2 : If all data is provided and consumed in a single round,
           this value is overriden by srcSize instead. 
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_loadDictionary(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);   </b>/* Not ready yet ! */<b>
</b><p>  Create an internal CDict from dict buffer.
  Decompression will have to use same buffer.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special : Adding a NULL (or 0-size) dictionary invalidates any previous prefix,
            meaning "return to no-dictionary mode".
  Note 1 : Dictionary content will be copied internally,
           except if ZSTD_p_refDictContent is set.
  Note 2 : Loading a dictionary involves building tables, which are dependent on compression parameters.
           For this reason, compression parameters cannot be changed anymore after loading a prefix.
           It's also a CPU-heavy operation, with non-negligible impact on latency.
  Note 3 : Dictionary will be used for all future compression jobs.
           To return to "no-dictionary" situation, load a NULL dictionary 
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refPrefix(ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize);   </b>/* Not ready yet ! */<b>
</b><p>  Reference a prefix (content-only dictionary) to bootstrap next compression job.
  Decompression will have to use same prefix.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special : Adding a NULL (or 0-size) dictionary invalidates any previous prefix, meaning "return to no-dictionary mode".
  Note 1 : Prefix buffer is referenced. It must outlive compression job.
  Note 3 : Prefix is only used once. Tables are discarded at end of compression job.
           If there is a need to use same prefix multiple times, consider embedding it into a ZSTD_CDict.
  Note 2 : Referencing a prefix involves building tables, which are dependent on compression parameters.
           For this reason, compression parameters cannot be changed anymore after loading a prefix.
           It's also a CPU-heavy operation, with non-negligible impact on latency. 
</p></pre><BR>

<pre><b>ZSTD_CDict* ZSTD_CDict_createEmpty(void);   </b>/* Not ready yet ! */<b>
size_t ZSTD_CDict_setParameter(ZSTD_CDict* cdict, ZSTD_cParameter param, unsigned value);  </b>/* Not ready yet ! */<b>
size_t ZSTD_CDict_loadDictionary(ZSTD_CDict* cdict, const void* dict, size_t dictSize);    </b>/* Not ready yet ! */<b>
</b><p>  Create a CDict object which is still mutable after creation.
  It's the only one case allowing usage of ZSTD_CDict_setParameter().
  Once all compression parameters are selected,
  it's possible to load the target dictionary, using ZSTD_CDict_loadDictionary().
  Dictionary content will be copied internally (except if ZSTD_p_refDictContent is set).
  After loading the dictionary, no more change is possible.
  The only remaining operation is to free CDict object.
  Note : An unfinished CDict behaves the same as a NULL CDict if referenced into a CCtx.
 
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict);
</b><p>  Add a prepared dictionary to cctx, to be used for next compression jobs.
  Note that compression parameters will be enforced from within CDict.
  Currently, they supercede any compression parameter previously set within CCtx.
  The dictionary will remain valid for future compression jobs using same cctx.
 @result : 0, or an error code (which can be tested with ZSTD_isError()).
  Special : adding a NULL CDict means "return to no-dictionary mode".
  Note 1 : Currently, only one dictionary can be managed.
           Adding a new dictionary effectively "discards" any previous one.
  Note 2 : CDict is just referenced, its lifetime must outlive CCtx.
 
</p></pre><BR>

<pre><b>typedef enum {
    ZSTD_e_continue=0, </b>/* collect more data, encoder transparently decides when to output result, for optimal conditions */<b>
    ZSTD_e_flush,      </b>/* flush any data provided so far - frame will continue, future data can still reference previous data for better compression */<b>
    ZSTD_e_end         </b>/* flush any remaining data and ends current frame. Any future compression starts a new frame. */<b>
} ZSTD_EndDirective;
</b></pre><BR>
<pre><b>size_t ZSTD_compress_generic (ZSTD_CCtx* cctx,
                              ZSTD_outBuffer* output,
                              ZSTD_inBuffer* input,
                              ZSTD_EndDirective endOp);
</b><p>  Behave about the same as ZSTD_compressStream. To note :
  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_setCCtxParameter()
  - Compression parameters cannot be changed once compression is started.
  - *dstPos must be <= dstCapacity, *srcPos must be <= srcSize
  - *dspPos and *srcPos will be updated. They are guaranteed to remain below their respective limit.
  - @return provides the amount of data ready to flush within internal buffers
            or an error code, which can be tested using ZSTD_isError().
            if @return != 0, flush is not fully completed, and must be called again to empty internal buffers.
  - after a ZSTD_e_end directive, if internal buffer is not fully flushed,
            only ZSTD_e_end and ZSTD_e_flush operations are allowed.
            It is necessary to fully flush internal buffers
            before changing compression parameters or start a new compression job.
 
</p></pre><BR>

<pre><b>size_t ZSTD_CCtx_reset(ZSTD_CCtx* cctx);   </b>/* Not ready yet ! */<b>
</b><p>  Return a CCtx to clean state.
  Useful after an error, or to interrupt an ongoing compression job and start a new one.
  It's possible to modify compression parameters after a reset.
  Any internal data not yet flushed is cancelled.
 
</p></pre><BR>

<a name="Chapter15"></a><h2>Advanced decompression functions</h2><pre></pre>

<pre><b>unsigned ZSTD_isFrame(const void* buffer, size_t size);
</b><p>  Tells if the content of `buffer` starts with a valid Frame Identifier.
  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
  Note 3 : Skippable Frame Identifiers are considered valid. 
</p></pre><BR>

<pre><b>ZSTD_DCtx* ZSTD_createDCtx_advanced(ZSTD_customMem customMem);
</b><p>  Create a ZSTD decompression context using external alloc and free functions 
</p></pre><BR>

<pre><b>ZSTD_DCtx* ZSTD_initStaticDCtx(void* workspace, size_t workspaceSize);
</b><p>  workspace: The memory area to emplace the context into.
             Provided pointer must 8-bytes aligned.
             It must outlive context usage.
  workspaceSize: Use ZSTD_estimateDCtxSize() or ZSTD_estimateDStreamSize()
                 to determine how large workspace must be to support scenario.
 @return : pointer to ZSTD_DCtx*, or NULL if error (size too small)
  Note : zstd will never resize nor malloc() when using a static dctx.
         If it needs more memory than available, it will simply error out.
  Note 2 : there is no corresponding "free" function.
           Since workspace was allocated externally, it must be freed externally.
  Limitation : currently not compatible with internal DDict creation,
               such as ZSTD_initDStream_usingDict().
 
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize);
</b><p>  Create a digested dictionary, ready to start decompression operation without startup delay.
  Dictionary content is simply referenced, and therefore stays in dictBuffer.
  It is important that dictBuffer outlives DDict, it must remain read accessible throughout the lifetime of DDict 
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_createDDict_advanced(const void* dict, size_t dictSize,
                                      unsigned byReference, ZSTD_customMem customMem);
</b><p>  Create a ZSTD_DDict using external alloc and free, optionally by reference 
</p></pre><BR>

<pre><b>ZSTD_DDict* ZSTD_initStaticDDict(void* workspace, size_t workspaceSize,
                                 const void* dict, size_t dictSize,
                                 unsigned byReference);
</b><p>  Generate a digested dictionary in provided memory area.
  workspace: The memory area to emplace the dictionary into.
             Provided pointer must 8-bytes aligned.
             It must outlive dictionary usage.
  workspaceSize: Use ZSTD_estimateDDictSize()
                 to determine how large workspace must be.
 @return : pointer to ZSTD_DDict*, or NULL if error (size too small)
  Note : there is no corresponding "free" function.
         Since workspace was allocated externally, it must be freed externally.
 
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize);
</b><p>  Provides the dictID stored within dictionary.
  if @return == 0, the dictionary is not conformant with Zstandard specification.
  It can still be loaded, but as a content-only dictionary. 
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict);
</b><p>  Provides the dictID of the dictionary loaded into `ddict`.
  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. 
</p></pre><BR>

<pre><b>unsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize);
</b><p>  Provides the dictID required to decompressed the frame stored within `src`.
  If @return == 0, the dictID could not be decoded.
  This could for one of the following reasons :
  - The frame does not require a dictionary to be decoded (most common case).
  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.
    Note : this use case also happens when using a non-conformant dictionary.
  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
  - This is not a Zstandard frame.
  When identifying the exact failure cause, it's possible to use ZSTD_getFrameParams(), which will provide a more precise error code. 
</p></pre><BR>

<a name="Chapter16"></a><h2>Advanced streaming functions</h2><pre></pre>

<h3>Advanced Streaming compression functions</h3><pre></pre><b><pre>ZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem);
size_t ZSTD_initCStream_srcSize(ZSTD_CStream* zcs, int compressionLevel, unsigned long long pledgedSrcSize);   </b>/**< pledgedSrcSize must be correct, a size of 0 means unknown.  for a frame size of 0 use initCStream_advanced */<b>
size_t ZSTD_initCStream_usingDict(ZSTD_CStream* zcs, const void* dict, size_t dictSize, int compressionLevel); </b>/**< creates of an internal CDict (incompatible with static CCtx), except if dict == NULL or dictSize < 8, in which case no dict is used. */<b>
size_t ZSTD_initCStream_advanced(ZSTD_CStream* zcs, const void* dict, size_t dictSize,
                                             ZSTD_parameters params, unsigned long long pledgedSrcSize);  </b>/**< pledgedSrcSize is optional and can be 0 (meaning unknown). note: if the contentSizeFlag is set, pledgedSrcSize == 0 means the source size is actually 0 */<b>
size_t ZSTD_initCStream_usingCDict(ZSTD_CStream* zcs, const ZSTD_CDict* cdict);  </b>/**< note : cdict will just be referenced, and must outlive compression session */<b>
size_t ZSTD_initCStream_usingCDict_advanced(ZSTD_CStream* zcs, const ZSTD_CDict* cdict, unsigned long long pledgedSrcSize, ZSTD_frameParameters fParams);  </b>/**< same as ZSTD_initCStream_usingCDict(), with control over frame parameters */<b>
</pre></b><BR>
<pre><b>size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pledgedSrcSize);
</b><p>  start a new compression job, using same parameters from previous job.
  This is typically useful to skip dictionary loading stage, since it will re-use it in-place..
  Note that zcs must be init at least once before using ZSTD_resetCStream().
  pledgedSrcSize==0 means "srcSize unknown".
  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.
  @return : 0, or an error code (which can be tested using ZSTD_isError()) 
</p></pre><BR>

<h3>Advanced Streaming decompression functions</h3><pre></pre><b><pre>typedef enum { DStream_p_maxWindowSize } ZSTD_DStreamParameter_e;
ZSTD_DStream* ZSTD_createDStream_advanced(ZSTD_customMem customMem);
size_t ZSTD_setDStreamParameter(ZSTD_DStream* zds, ZSTD_DStreamParameter_e paramType, unsigned paramValue);
size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize); </b>/**< note: a dict will not be used if dict == NULL or dictSize < 8 */<b>
size_t ZSTD_initDStream_usingDDict(ZSTD_DStream* zds, const ZSTD_DDict* ddict);  </b>/**< note : ddict will just be referenced, and must outlive decompression session */<b>
size_t ZSTD_resetDStream(ZSTD_DStream* zds);  </b>/**< re-use decompression parameters from previous init; saves dictionary loading */<b>
</pre></b><BR>
<a name="Chapter17"></a><h2>Buffer-less and synchronous inner streaming functions</h2><pre>
  This is an advanced API, giving full control over buffer management, for users which need direct control over memory.
  But it's also a complex one, with many restrictions (documented below).
  Prefer using normal streaming API for an easier experience
 
<BR></pre>

<a name="Chapter18"></a><h2>Buffer-less streaming compression (synchronous mode)</h2><pre>
  A ZSTD_CCtx object is required to track streaming operations.
  Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.
  ZSTD_CCtx object can be re-used multiple times within successive compression operations.

  Start by initializing a context.
  Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,
  or ZSTD_compressBegin_advanced(), for finer parameter control.
  It's also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()

  Then, consume your input using ZSTD_compressContinue().
  There are some important considerations to keep in mind when using this advanced function :
  - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffer only.
  - Interface is synchronous : input is consumed entirely and produce 1+ (or more) compressed blocks.
  - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.
    Worst case evaluation is provided by ZSTD_compressBound().
    ZSTD_compressContinue() doesn't guarantee recover after a failed compression.
  - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).
    It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)
  - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.
    In which case, it will "discard" the relevant memory section from its history.

  Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.
  It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.
  Without last block mark, frames will be considered unfinished (corrupted) by decoders.

  `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress some new frame.
<BR></pre>

<h3>Buffer-less streaming compression functions</h3><pre></pre><b><pre>size_t ZSTD_compressBegin(ZSTD_CCtx* cctx, int compressionLevel);
size_t ZSTD_compressBegin_usingDict(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel);
size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_parameters params, unsigned long long pledgedSrcSize); </b>/**< pledgedSrcSize is optional and can be 0 (meaning unknown). note: if the contentSizeFlag is set, pledgedSrcSize == 0 means the source size is actually 0 */<b>
size_t ZSTD_compressBegin_usingCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict); </b>/**< note: fails if cdict==NULL */<b>
size_t ZSTD_compressBegin_usingCDict_advanced(ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict, ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize);   </b>/* compression parameters are already set within cdict. pledgedSrcSize=0 means null-size */<b>
size_t ZSTD_copyCCtx(ZSTD_CCtx* cctx, const ZSTD_CCtx* preparedCCtx, unsigned long long pledgedSrcSize); </b>/**<  note: if pledgedSrcSize can be 0, indicating unknown size.  if it is non-zero, it must be accurate.  for 0 size frames, use compressBegin_advanced */<b>
</pre></b><BR>
<a name="Chapter19"></a><h2>Buffer-less streaming decompression (synchronous mode)</h2><pre>
  A ZSTD_DCtx object is required to track streaming operations.
  Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.
  A ZSTD_DCtx object can be re-used multiple times.

  First typical operation is to retrieve frame parameters, using ZSTD_getFrameParams().
  It fills a ZSTD_frameParams structure which provide important information to correctly decode the frame,
  such as the minimum rolling buffer size to allocate to decompress data (`windowSize`),
  and the dictionary ID used.
  (Note : content size is optional, it may not be present. 0 means : content size unknown).
  Note that these values could be wrong, either because of data malformation, or because an attacker is spoofing deliberate false information.
  As a consequence, check that values remain within valid application range, especially `windowSize`, before allocation.
  Each application can set its own limit, depending on local restrictions. For extended interoperability, it is recommended to support at least 8 MB.
  Frame parameters are extracted from the beginning of the compressed frame.
  Data fragment must be large enough to ensure successful decoding, typically `ZSTD_frameHeaderSize_max` bytes.
  @result : 0 : successful decoding, the `ZSTD_frameParams` structure is correctly filled.
           >0 : `srcSize` is too small, please provide at least @result bytes on next attempt.
           errorCode, which can be tested using ZSTD_isError().

  Start decompression, with ZSTD_decompressBegin().
  If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().
  Alternatively, you can copy a prepared context, using ZSTD_copyDCtx().

  Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.
  ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().
  ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.

  @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily <= dstCapacity).
  It can be zero, which is not an error; it just means ZSTD_decompressContinue() has decoded some metadata item.
  It can also be an error code, which can be tested with ZSTD_isError().

  ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize`.
  They should preferably be located contiguously, prior to current block.
  Alternatively, a round buffer of sufficient size is also possible. Sufficient size is determined by frame parameters.
  ZSTD_decompressContinue() is very sensitive to contiguity,
  if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,
  or that previous contiguous segment is large enough to properly handle maximum back-reference.

  A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.
  Context can then be reset to start a new decompression.

  Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().
  This information is not required to properly decode a frame.

  == Special case : skippable frames 

  Skippable frames allow integration of user-defined data into a flow of concatenated frames.
  Skippable frames will be ignored (skipped) by a decompressor. The format of skippable frames is as follows :
  a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F
  b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits
  c) Frame Content - any content (User Data) of length equal to Frame Size
  For skippable frames ZSTD_decompressContinue() always returns 0.
  For skippable frames ZSTD_getFrameParams() returns fparamsPtr->windowLog==0 what means that a frame is skippable.
    Note : If fparamsPtr->frameContentSize==0, it is ambiguous: the frame might actually be a Zstd encoded frame with no content.
           For purposes of decompression, it is valid in both cases to skip the frame using
           ZSTD_findFrameCompressedSize to find its size in bytes.
  It also returns Frame Size as fparamsPtr->frameContentSize.
<BR></pre>

<h3>Buffer-less streaming decompression functions</h3><pre></pre><b><pre>size_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize);   </b>/**< doesn't consume input, see details below */<b>
size_t ZSTD_decompressBegin(ZSTD_DCtx* dctx);
size_t ZSTD_decompressBegin_usingDict(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
size_t ZSTD_decompressBegin_usingDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);
void   ZSTD_copyDCtx(ZSTD_DCtx* dctx, const ZSTD_DCtx* preparedDCtx);
</pre></b><BR>
<pre><b>typedef enum { ZSTDnit_frameHeader, ZSTDnit_blockHeader, ZSTDnit_block, ZSTDnit_lastBlock, ZSTDnit_checksum, ZSTDnit_skippableFrame } ZSTD_nextInputType_e;
</b></pre><BR>
<a name="Chapter20"></a><h2>Block functions</h2><pre>
    Block functions produce and decode raw zstd blocks, without frame metadata.
    Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes).
    User will have to take in charge required information to regenerate data, such as compressed and content sizes.

    A few rules to respect :
    - Compressing and decompressing require a context structure
      + Use ZSTD_createCCtx() and ZSTD_createDCtx()
    - It is necessary to init context before starting
      + compression : any ZSTD_compressBegin*() variant, including with dictionary
      + decompression : any ZSTD_decompressBegin*() variant, including with dictionary
      + copyCCtx() and copyDCtx() can be used too
    - Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX
      + If input is larger than a block size, it's necessary to split input data into multiple blocks
      + For inputs larger than a single block size, consider using the regular ZSTD_compress() instead.
        Frame metadata is not that costly, and quickly becomes negligible as source size grows larger.
    - When a block is considered not compressible enough, ZSTD_compressBlock() result will be zero.
      In which case, nothing is produced into `dst`.
      + User must test for such outcome and deal directly with uncompressed data
      + ZSTD_decompressBlock() doesn't accept uncompressed data as input !!!
      + In case of multiple successive blocks, should some of them be uncompressed,
        decoder must be informed of their existence in order to follow proper history.
        Use ZSTD_insertBlock() for such a case.
<BR></pre>

<h3>Raw zstd block functions</h3><pre></pre><b><pre>size_t ZSTD_getBlockSize   (const ZSTD_CCtx* cctx);
size_t ZSTD_compressBlock  (ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
size_t ZSTD_decompressBlock(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
size_t ZSTD_insertBlock(ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize);  </b>/**< insert block into `dctx` history. Useful for uncompressed blocks */<b>
</pre></b><BR>
</html>
</body>
